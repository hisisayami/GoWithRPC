// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"

	"example.com/go-inventory-grpc/ent/category"
	"example.com/go-inventory-grpc/ent/orderdetails"
	"example.com/go-inventory-grpc/ent/predicate"
	"example.com/go-inventory-grpc/ent/product"
	"example.com/go-inventory-grpc/ent/staff"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCategory     = "Category"
	TypeOrderDetails = "OrderDetails"
	TypeProduct      = "Product"
	TypeStaff        = "Staff"
)

// CategoryMutation represents an operation that mutates the Category nodes in the graph.
type CategoryMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	category_id          *int
	addcategory_id       *int
	category_name        *string
	category_description *string
	clearedFields        map[string]struct{}
	products             map[int]struct{}
	removedproducts      map[int]struct{}
	clearedproducts      bool
	done                 bool
	oldValue             func(context.Context) (*Category, error)
	predicates           []predicate.Category
}

var _ ent.Mutation = (*CategoryMutation)(nil)

// categoryOption allows management of the mutation configuration using functional options.
type categoryOption func(*CategoryMutation)

// newCategoryMutation creates new mutation for the Category entity.
func newCategoryMutation(c config, op Op, opts ...categoryOption) *CategoryMutation {
	m := &CategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCategoryID sets the ID field of the mutation.
func withCategoryID(id int) categoryOption {
	return func(m *CategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *Category
		)
		m.oldValue = func(ctx context.Context) (*Category, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Category.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCategory sets the old Category of the mutation.
func withCategory(node *Category) categoryOption {
	return func(m *CategoryMutation) {
		m.oldValue = func(context.Context) (*Category, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CategoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CategoryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Category.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCategoryID sets the "category_id" field.
func (m *CategoryMutation) SetCategoryID(i int) {
	m.category_id = &i
	m.addcategory_id = nil
}

// CategoryID returns the value of the "category_id" field in the mutation.
func (m *CategoryMutation) CategoryID() (r int, exists bool) {
	v := m.category_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryID returns the old "category_id" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldCategoryID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategoryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategoryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryID: %w", err)
	}
	return oldValue.CategoryID, nil
}

// AddCategoryID adds i to the "category_id" field.
func (m *CategoryMutation) AddCategoryID(i int) {
	if m.addcategory_id != nil {
		*m.addcategory_id += i
	} else {
		m.addcategory_id = &i
	}
}

// AddedCategoryID returns the value that was added to the "category_id" field in this mutation.
func (m *CategoryMutation) AddedCategoryID() (r int, exists bool) {
	v := m.addcategory_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetCategoryID resets all changes to the "category_id" field.
func (m *CategoryMutation) ResetCategoryID() {
	m.category_id = nil
	m.addcategory_id = nil
}

// SetCategoryName sets the "category_name" field.
func (m *CategoryMutation) SetCategoryName(s string) {
	m.category_name = &s
}

// CategoryName returns the value of the "category_name" field in the mutation.
func (m *CategoryMutation) CategoryName() (r string, exists bool) {
	v := m.category_name
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryName returns the old "category_name" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldCategoryName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategoryName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategoryName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryName: %w", err)
	}
	return oldValue.CategoryName, nil
}

// ResetCategoryName resets all changes to the "category_name" field.
func (m *CategoryMutation) ResetCategoryName() {
	m.category_name = nil
}

// SetCategoryDescription sets the "category_description" field.
func (m *CategoryMutation) SetCategoryDescription(s string) {
	m.category_description = &s
}

// CategoryDescription returns the value of the "category_description" field in the mutation.
func (m *CategoryMutation) CategoryDescription() (r string, exists bool) {
	v := m.category_description
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryDescription returns the old "category_description" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldCategoryDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategoryDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategoryDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryDescription: %w", err)
	}
	return oldValue.CategoryDescription, nil
}

// ResetCategoryDescription resets all changes to the "category_description" field.
func (m *CategoryMutation) ResetCategoryDescription() {
	m.category_description = nil
}

// AddProductIDs adds the "products" edge to the Product entity by ids.
func (m *CategoryMutation) AddProductIDs(ids ...int) {
	if m.products == nil {
		m.products = make(map[int]struct{})
	}
	for i := range ids {
		m.products[ids[i]] = struct{}{}
	}
}

// ClearProducts clears the "products" edge to the Product entity.
func (m *CategoryMutation) ClearProducts() {
	m.clearedproducts = true
}

// ProductsCleared reports if the "products" edge to the Product entity was cleared.
func (m *CategoryMutation) ProductsCleared() bool {
	return m.clearedproducts
}

// RemoveProductIDs removes the "products" edge to the Product entity by IDs.
func (m *CategoryMutation) RemoveProductIDs(ids ...int) {
	if m.removedproducts == nil {
		m.removedproducts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.products, ids[i])
		m.removedproducts[ids[i]] = struct{}{}
	}
}

// RemovedProducts returns the removed IDs of the "products" edge to the Product entity.
func (m *CategoryMutation) RemovedProductsIDs() (ids []int) {
	for id := range m.removedproducts {
		ids = append(ids, id)
	}
	return
}

// ProductsIDs returns the "products" edge IDs in the mutation.
func (m *CategoryMutation) ProductsIDs() (ids []int) {
	for id := range m.products {
		ids = append(ids, id)
	}
	return
}

// ResetProducts resets all changes to the "products" edge.
func (m *CategoryMutation) ResetProducts() {
	m.products = nil
	m.clearedproducts = false
	m.removedproducts = nil
}

// Where appends a list predicates to the CategoryMutation builder.
func (m *CategoryMutation) Where(ps ...predicate.Category) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CategoryMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Category).
func (m *CategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CategoryMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.category_id != nil {
		fields = append(fields, category.FieldCategoryID)
	}
	if m.category_name != nil {
		fields = append(fields, category.FieldCategoryName)
	}
	if m.category_description != nil {
		fields = append(fields, category.FieldCategoryDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case category.FieldCategoryID:
		return m.CategoryID()
	case category.FieldCategoryName:
		return m.CategoryName()
	case category.FieldCategoryDescription:
		return m.CategoryDescription()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case category.FieldCategoryID:
		return m.OldCategoryID(ctx)
	case category.FieldCategoryName:
		return m.OldCategoryName(ctx)
	case category.FieldCategoryDescription:
		return m.OldCategoryDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Category field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case category.FieldCategoryID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryID(v)
		return nil
	case category.FieldCategoryName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryName(v)
		return nil
	case category.FieldCategoryDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Category field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CategoryMutation) AddedFields() []string {
	var fields []string
	if m.addcategory_id != nil {
		fields = append(fields, category.FieldCategoryID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CategoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case category.FieldCategoryID:
		return m.AddedCategoryID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case category.FieldCategoryID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCategoryID(v)
		return nil
	}
	return fmt.Errorf("unknown Category numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CategoryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CategoryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Category nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CategoryMutation) ResetField(name string) error {
	switch name {
	case category.FieldCategoryID:
		m.ResetCategoryID()
		return nil
	case category.FieldCategoryName:
		m.ResetCategoryName()
		return nil
	case category.FieldCategoryDescription:
		m.ResetCategoryDescription()
		return nil
	}
	return fmt.Errorf("unknown Category field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.products != nil {
		edges = append(edges, category.EdgeProducts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CategoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case category.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.products))
		for id := range m.products {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedproducts != nil {
		edges = append(edges, category.EdgeProducts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CategoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case category.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.removedproducts))
		for id := range m.removedproducts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedproducts {
		edges = append(edges, category.EdgeProducts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CategoryMutation) EdgeCleared(name string) bool {
	switch name {
	case category.EdgeProducts:
		return m.clearedproducts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CategoryMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Category unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CategoryMutation) ResetEdge(name string) error {
	switch name {
	case category.EdgeProducts:
		m.ResetProducts()
		return nil
	}
	return fmt.Errorf("unknown Category edge %s", name)
}

// OrderDetailsMutation represents an operation that mutates the OrderDetails nodes in the graph.
type OrderDetailsMutation struct {
	config
	op                Op
	typ               string
	id                *int
	_OrderDetailId    *int
	add_OrderDetailId *int
	_OrderId          *int
	add_OrderId       *int
	_ProductId        *int
	add_ProductId     *int
	_UnitPrice        *int
	add_UnitPrice     *int
	_Quantity         *int
	add_Quantity      *int
	_TotalPrice       *int
	add_TotalPrice    *int
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*OrderDetails, error)
	predicates        []predicate.OrderDetails
}

var _ ent.Mutation = (*OrderDetailsMutation)(nil)

// orderdetailsOption allows management of the mutation configuration using functional options.
type orderdetailsOption func(*OrderDetailsMutation)

// newOrderDetailsMutation creates new mutation for the OrderDetails entity.
func newOrderDetailsMutation(c config, op Op, opts ...orderdetailsOption) *OrderDetailsMutation {
	m := &OrderDetailsMutation{
		config:        c,
		op:            op,
		typ:           TypeOrderDetails,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderDetailsID sets the ID field of the mutation.
func withOrderDetailsID(id int) orderdetailsOption {
	return func(m *OrderDetailsMutation) {
		var (
			err   error
			once  sync.Once
			value *OrderDetails
		)
		m.oldValue = func(ctx context.Context) (*OrderDetails, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrderDetails.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrderDetails sets the old OrderDetails of the mutation.
func withOrderDetails(node *OrderDetails) orderdetailsOption {
	return func(m *OrderDetailsMutation) {
		m.oldValue = func(context.Context) (*OrderDetails, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderDetailsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderDetailsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderDetailsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderDetailsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrderDetails.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOrderDetailId sets the "OrderDetailId" field.
func (m *OrderDetailsMutation) SetOrderDetailId(i int) {
	m._OrderDetailId = &i
	m.add_OrderDetailId = nil
}

// OrderDetailId returns the value of the "OrderDetailId" field in the mutation.
func (m *OrderDetailsMutation) OrderDetailId() (r int, exists bool) {
	v := m._OrderDetailId
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderDetailId returns the old "OrderDetailId" field's value of the OrderDetails entity.
// If the OrderDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderDetailsMutation) OldOrderDetailId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderDetailId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderDetailId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderDetailId: %w", err)
	}
	return oldValue.OrderDetailId, nil
}

// AddOrderDetailId adds i to the "OrderDetailId" field.
func (m *OrderDetailsMutation) AddOrderDetailId(i int) {
	if m.add_OrderDetailId != nil {
		*m.add_OrderDetailId += i
	} else {
		m.add_OrderDetailId = &i
	}
}

// AddedOrderDetailId returns the value that was added to the "OrderDetailId" field in this mutation.
func (m *OrderDetailsMutation) AddedOrderDetailId() (r int, exists bool) {
	v := m.add_OrderDetailId
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrderDetailId resets all changes to the "OrderDetailId" field.
func (m *OrderDetailsMutation) ResetOrderDetailId() {
	m._OrderDetailId = nil
	m.add_OrderDetailId = nil
}

// SetOrderId sets the "OrderId" field.
func (m *OrderDetailsMutation) SetOrderId(i int) {
	m._OrderId = &i
	m.add_OrderId = nil
}

// OrderId returns the value of the "OrderId" field in the mutation.
func (m *OrderDetailsMutation) OrderId() (r int, exists bool) {
	v := m._OrderId
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderId returns the old "OrderId" field's value of the OrderDetails entity.
// If the OrderDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderDetailsMutation) OldOrderId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderId: %w", err)
	}
	return oldValue.OrderId, nil
}

// AddOrderId adds i to the "OrderId" field.
func (m *OrderDetailsMutation) AddOrderId(i int) {
	if m.add_OrderId != nil {
		*m.add_OrderId += i
	} else {
		m.add_OrderId = &i
	}
}

// AddedOrderId returns the value that was added to the "OrderId" field in this mutation.
func (m *OrderDetailsMutation) AddedOrderId() (r int, exists bool) {
	v := m.add_OrderId
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrderId resets all changes to the "OrderId" field.
func (m *OrderDetailsMutation) ResetOrderId() {
	m._OrderId = nil
	m.add_OrderId = nil
}

// SetProductId sets the "ProductId" field.
func (m *OrderDetailsMutation) SetProductId(i int) {
	m._ProductId = &i
	m.add_ProductId = nil
}

// ProductId returns the value of the "ProductId" field in the mutation.
func (m *OrderDetailsMutation) ProductId() (r int, exists bool) {
	v := m._ProductId
	if v == nil {
		return
	}
	return *v, true
}

// OldProductId returns the old "ProductId" field's value of the OrderDetails entity.
// If the OrderDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderDetailsMutation) OldProductId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductId: %w", err)
	}
	return oldValue.ProductId, nil
}

// AddProductId adds i to the "ProductId" field.
func (m *OrderDetailsMutation) AddProductId(i int) {
	if m.add_ProductId != nil {
		*m.add_ProductId += i
	} else {
		m.add_ProductId = &i
	}
}

// AddedProductId returns the value that was added to the "ProductId" field in this mutation.
func (m *OrderDetailsMutation) AddedProductId() (r int, exists bool) {
	v := m.add_ProductId
	if v == nil {
		return
	}
	return *v, true
}

// ResetProductId resets all changes to the "ProductId" field.
func (m *OrderDetailsMutation) ResetProductId() {
	m._ProductId = nil
	m.add_ProductId = nil
}

// SetUnitPrice sets the "UnitPrice" field.
func (m *OrderDetailsMutation) SetUnitPrice(i int) {
	m._UnitPrice = &i
	m.add_UnitPrice = nil
}

// UnitPrice returns the value of the "UnitPrice" field in the mutation.
func (m *OrderDetailsMutation) UnitPrice() (r int, exists bool) {
	v := m._UnitPrice
	if v == nil {
		return
	}
	return *v, true
}

// OldUnitPrice returns the old "UnitPrice" field's value of the OrderDetails entity.
// If the OrderDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderDetailsMutation) OldUnitPrice(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnitPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnitPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnitPrice: %w", err)
	}
	return oldValue.UnitPrice, nil
}

// AddUnitPrice adds i to the "UnitPrice" field.
func (m *OrderDetailsMutation) AddUnitPrice(i int) {
	if m.add_UnitPrice != nil {
		*m.add_UnitPrice += i
	} else {
		m.add_UnitPrice = &i
	}
}

// AddedUnitPrice returns the value that was added to the "UnitPrice" field in this mutation.
func (m *OrderDetailsMutation) AddedUnitPrice() (r int, exists bool) {
	v := m.add_UnitPrice
	if v == nil {
		return
	}
	return *v, true
}

// ResetUnitPrice resets all changes to the "UnitPrice" field.
func (m *OrderDetailsMutation) ResetUnitPrice() {
	m._UnitPrice = nil
	m.add_UnitPrice = nil
}

// SetQuantity sets the "Quantity" field.
func (m *OrderDetailsMutation) SetQuantity(i int) {
	m._Quantity = &i
	m.add_Quantity = nil
}

// Quantity returns the value of the "Quantity" field in the mutation.
func (m *OrderDetailsMutation) Quantity() (r int, exists bool) {
	v := m._Quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantity returns the old "Quantity" field's value of the OrderDetails entity.
// If the OrderDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderDetailsMutation) OldQuantity(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantity: %w", err)
	}
	return oldValue.Quantity, nil
}

// AddQuantity adds i to the "Quantity" field.
func (m *OrderDetailsMutation) AddQuantity(i int) {
	if m.add_Quantity != nil {
		*m.add_Quantity += i
	} else {
		m.add_Quantity = &i
	}
}

// AddedQuantity returns the value that was added to the "Quantity" field in this mutation.
func (m *OrderDetailsMutation) AddedQuantity() (r int, exists bool) {
	v := m.add_Quantity
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuantity resets all changes to the "Quantity" field.
func (m *OrderDetailsMutation) ResetQuantity() {
	m._Quantity = nil
	m.add_Quantity = nil
}

// SetTotalPrice sets the "TotalPrice" field.
func (m *OrderDetailsMutation) SetTotalPrice(i int) {
	m._TotalPrice = &i
	m.add_TotalPrice = nil
}

// TotalPrice returns the value of the "TotalPrice" field in the mutation.
func (m *OrderDetailsMutation) TotalPrice() (r int, exists bool) {
	v := m._TotalPrice
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalPrice returns the old "TotalPrice" field's value of the OrderDetails entity.
// If the OrderDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderDetailsMutation) OldTotalPrice(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalPrice: %w", err)
	}
	return oldValue.TotalPrice, nil
}

// AddTotalPrice adds i to the "TotalPrice" field.
func (m *OrderDetailsMutation) AddTotalPrice(i int) {
	if m.add_TotalPrice != nil {
		*m.add_TotalPrice += i
	} else {
		m.add_TotalPrice = &i
	}
}

// AddedTotalPrice returns the value that was added to the "TotalPrice" field in this mutation.
func (m *OrderDetailsMutation) AddedTotalPrice() (r int, exists bool) {
	v := m.add_TotalPrice
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalPrice resets all changes to the "TotalPrice" field.
func (m *OrderDetailsMutation) ResetTotalPrice() {
	m._TotalPrice = nil
	m.add_TotalPrice = nil
}

// Where appends a list predicates to the OrderDetailsMutation builder.
func (m *OrderDetailsMutation) Where(ps ...predicate.OrderDetails) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *OrderDetailsMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (OrderDetails).
func (m *OrderDetailsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderDetailsMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m._OrderDetailId != nil {
		fields = append(fields, orderdetails.FieldOrderDetailId)
	}
	if m._OrderId != nil {
		fields = append(fields, orderdetails.FieldOrderId)
	}
	if m._ProductId != nil {
		fields = append(fields, orderdetails.FieldProductId)
	}
	if m._UnitPrice != nil {
		fields = append(fields, orderdetails.FieldUnitPrice)
	}
	if m._Quantity != nil {
		fields = append(fields, orderdetails.FieldQuantity)
	}
	if m._TotalPrice != nil {
		fields = append(fields, orderdetails.FieldTotalPrice)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderDetailsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orderdetails.FieldOrderDetailId:
		return m.OrderDetailId()
	case orderdetails.FieldOrderId:
		return m.OrderId()
	case orderdetails.FieldProductId:
		return m.ProductId()
	case orderdetails.FieldUnitPrice:
		return m.UnitPrice()
	case orderdetails.FieldQuantity:
		return m.Quantity()
	case orderdetails.FieldTotalPrice:
		return m.TotalPrice()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderDetailsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orderdetails.FieldOrderDetailId:
		return m.OldOrderDetailId(ctx)
	case orderdetails.FieldOrderId:
		return m.OldOrderId(ctx)
	case orderdetails.FieldProductId:
		return m.OldProductId(ctx)
	case orderdetails.FieldUnitPrice:
		return m.OldUnitPrice(ctx)
	case orderdetails.FieldQuantity:
		return m.OldQuantity(ctx)
	case orderdetails.FieldTotalPrice:
		return m.OldTotalPrice(ctx)
	}
	return nil, fmt.Errorf("unknown OrderDetails field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderDetailsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orderdetails.FieldOrderDetailId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderDetailId(v)
		return nil
	case orderdetails.FieldOrderId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderId(v)
		return nil
	case orderdetails.FieldProductId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductId(v)
		return nil
	case orderdetails.FieldUnitPrice:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnitPrice(v)
		return nil
	case orderdetails.FieldQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantity(v)
		return nil
	case orderdetails.FieldTotalPrice:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalPrice(v)
		return nil
	}
	return fmt.Errorf("unknown OrderDetails field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderDetailsMutation) AddedFields() []string {
	var fields []string
	if m.add_OrderDetailId != nil {
		fields = append(fields, orderdetails.FieldOrderDetailId)
	}
	if m.add_OrderId != nil {
		fields = append(fields, orderdetails.FieldOrderId)
	}
	if m.add_ProductId != nil {
		fields = append(fields, orderdetails.FieldProductId)
	}
	if m.add_UnitPrice != nil {
		fields = append(fields, orderdetails.FieldUnitPrice)
	}
	if m.add_Quantity != nil {
		fields = append(fields, orderdetails.FieldQuantity)
	}
	if m.add_TotalPrice != nil {
		fields = append(fields, orderdetails.FieldTotalPrice)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderDetailsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case orderdetails.FieldOrderDetailId:
		return m.AddedOrderDetailId()
	case orderdetails.FieldOrderId:
		return m.AddedOrderId()
	case orderdetails.FieldProductId:
		return m.AddedProductId()
	case orderdetails.FieldUnitPrice:
		return m.AddedUnitPrice()
	case orderdetails.FieldQuantity:
		return m.AddedQuantity()
	case orderdetails.FieldTotalPrice:
		return m.AddedTotalPrice()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderDetailsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case orderdetails.FieldOrderDetailId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderDetailId(v)
		return nil
	case orderdetails.FieldOrderId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderId(v)
		return nil
	case orderdetails.FieldProductId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProductId(v)
		return nil
	case orderdetails.FieldUnitPrice:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUnitPrice(v)
		return nil
	case orderdetails.FieldQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuantity(v)
		return nil
	case orderdetails.FieldTotalPrice:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalPrice(v)
		return nil
	}
	return fmt.Errorf("unknown OrderDetails numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderDetailsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderDetailsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderDetailsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown OrderDetails nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderDetailsMutation) ResetField(name string) error {
	switch name {
	case orderdetails.FieldOrderDetailId:
		m.ResetOrderDetailId()
		return nil
	case orderdetails.FieldOrderId:
		m.ResetOrderId()
		return nil
	case orderdetails.FieldProductId:
		m.ResetProductId()
		return nil
	case orderdetails.FieldUnitPrice:
		m.ResetUnitPrice()
		return nil
	case orderdetails.FieldQuantity:
		m.ResetQuantity()
		return nil
	case orderdetails.FieldTotalPrice:
		m.ResetTotalPrice()
		return nil
	}
	return fmt.Errorf("unknown OrderDetails field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderDetailsMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderDetailsMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderDetailsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderDetailsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderDetailsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderDetailsMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderDetailsMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown OrderDetails unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderDetailsMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown OrderDetails edge %s", name)
}

// ProductMutation represents an operation that mutates the Product nodes in the graph.
type ProductMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	product_id          *int
	addproduct_id       *int
	product_name        *string
	product_description *string
	product_quantity    *int
	addproduct_quantity *int
	unit_price          *int
	addunit_price       *int
	clearedFields       map[string]struct{}
	category_id         *int
	clearedcategory_id  bool
	done                bool
	oldValue            func(context.Context) (*Product, error)
	predicates          []predicate.Product
}

var _ ent.Mutation = (*ProductMutation)(nil)

// productOption allows management of the mutation configuration using functional options.
type productOption func(*ProductMutation)

// newProductMutation creates new mutation for the Product entity.
func newProductMutation(c config, op Op, opts ...productOption) *ProductMutation {
	m := &ProductMutation{
		config:        c,
		op:            op,
		typ:           TypeProduct,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductID sets the ID field of the mutation.
func withProductID(id int) productOption {
	return func(m *ProductMutation) {
		var (
			err   error
			once  sync.Once
			value *Product
		)
		m.oldValue = func(ctx context.Context) (*Product, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Product.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProduct sets the old Product of the mutation.
func withProduct(node *Product) productOption {
	return func(m *ProductMutation) {
		m.oldValue = func(context.Context) (*Product, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProductMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Product.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetProductID sets the "product_id" field.
func (m *ProductMutation) SetProductID(i int) {
	m.product_id = &i
	m.addproduct_id = nil
}

// ProductID returns the value of the "product_id" field in the mutation.
func (m *ProductMutation) ProductID() (r int, exists bool) {
	v := m.product_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProductID returns the old "product_id" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldProductID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductID: %w", err)
	}
	return oldValue.ProductID, nil
}

// AddProductID adds i to the "product_id" field.
func (m *ProductMutation) AddProductID(i int) {
	if m.addproduct_id != nil {
		*m.addproduct_id += i
	} else {
		m.addproduct_id = &i
	}
}

// AddedProductID returns the value that was added to the "product_id" field in this mutation.
func (m *ProductMutation) AddedProductID() (r int, exists bool) {
	v := m.addproduct_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetProductID resets all changes to the "product_id" field.
func (m *ProductMutation) ResetProductID() {
	m.product_id = nil
	m.addproduct_id = nil
}

// SetProductName sets the "product_name" field.
func (m *ProductMutation) SetProductName(s string) {
	m.product_name = &s
}

// ProductName returns the value of the "product_name" field in the mutation.
func (m *ProductMutation) ProductName() (r string, exists bool) {
	v := m.product_name
	if v == nil {
		return
	}
	return *v, true
}

// OldProductName returns the old "product_name" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldProductName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductName: %w", err)
	}
	return oldValue.ProductName, nil
}

// ResetProductName resets all changes to the "product_name" field.
func (m *ProductMutation) ResetProductName() {
	m.product_name = nil
}

// SetProductDescription sets the "product_description" field.
func (m *ProductMutation) SetProductDescription(s string) {
	m.product_description = &s
}

// ProductDescription returns the value of the "product_description" field in the mutation.
func (m *ProductMutation) ProductDescription() (r string, exists bool) {
	v := m.product_description
	if v == nil {
		return
	}
	return *v, true
}

// OldProductDescription returns the old "product_description" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldProductDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductDescription: %w", err)
	}
	return oldValue.ProductDescription, nil
}

// ResetProductDescription resets all changes to the "product_description" field.
func (m *ProductMutation) ResetProductDescription() {
	m.product_description = nil
}

// SetProductQuantity sets the "product_quantity" field.
func (m *ProductMutation) SetProductQuantity(i int) {
	m.product_quantity = &i
	m.addproduct_quantity = nil
}

// ProductQuantity returns the value of the "product_quantity" field in the mutation.
func (m *ProductMutation) ProductQuantity() (r int, exists bool) {
	v := m.product_quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldProductQuantity returns the old "product_quantity" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldProductQuantity(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductQuantity: %w", err)
	}
	return oldValue.ProductQuantity, nil
}

// AddProductQuantity adds i to the "product_quantity" field.
func (m *ProductMutation) AddProductQuantity(i int) {
	if m.addproduct_quantity != nil {
		*m.addproduct_quantity += i
	} else {
		m.addproduct_quantity = &i
	}
}

// AddedProductQuantity returns the value that was added to the "product_quantity" field in this mutation.
func (m *ProductMutation) AddedProductQuantity() (r int, exists bool) {
	v := m.addproduct_quantity
	if v == nil {
		return
	}
	return *v, true
}

// ResetProductQuantity resets all changes to the "product_quantity" field.
func (m *ProductMutation) ResetProductQuantity() {
	m.product_quantity = nil
	m.addproduct_quantity = nil
}

// SetUnitPrice sets the "unit_price" field.
func (m *ProductMutation) SetUnitPrice(i int) {
	m.unit_price = &i
	m.addunit_price = nil
}

// UnitPrice returns the value of the "unit_price" field in the mutation.
func (m *ProductMutation) UnitPrice() (r int, exists bool) {
	v := m.unit_price
	if v == nil {
		return
	}
	return *v, true
}

// OldUnitPrice returns the old "unit_price" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldUnitPrice(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnitPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnitPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnitPrice: %w", err)
	}
	return oldValue.UnitPrice, nil
}

// AddUnitPrice adds i to the "unit_price" field.
func (m *ProductMutation) AddUnitPrice(i int) {
	if m.addunit_price != nil {
		*m.addunit_price += i
	} else {
		m.addunit_price = &i
	}
}

// AddedUnitPrice returns the value that was added to the "unit_price" field in this mutation.
func (m *ProductMutation) AddedUnitPrice() (r int, exists bool) {
	v := m.addunit_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetUnitPrice resets all changes to the "unit_price" field.
func (m *ProductMutation) ResetUnitPrice() {
	m.unit_price = nil
	m.addunit_price = nil
}

// SetCategoryIDID sets the "category_id" edge to the Category entity by id.
func (m *ProductMutation) SetCategoryIDID(id int) {
	m.category_id = &id
}

// ClearCategoryID clears the "category_id" edge to the Category entity.
func (m *ProductMutation) ClearCategoryID() {
	m.clearedcategory_id = true
}

// CategoryIDCleared reports if the "category_id" edge to the Category entity was cleared.
func (m *ProductMutation) CategoryIDCleared() bool {
	return m.clearedcategory_id
}

// CategoryIDID returns the "category_id" edge ID in the mutation.
func (m *ProductMutation) CategoryIDID() (id int, exists bool) {
	if m.category_id != nil {
		return *m.category_id, true
	}
	return
}

// CategoryIDIDs returns the "category_id" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CategoryIDID instead. It exists only for internal usage by the builders.
func (m *ProductMutation) CategoryIDIDs() (ids []int) {
	if id := m.category_id; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCategoryID resets all changes to the "category_id" edge.
func (m *ProductMutation) ResetCategoryID() {
	m.category_id = nil
	m.clearedcategory_id = false
}

// Where appends a list predicates to the ProductMutation builder.
func (m *ProductMutation) Where(ps ...predicate.Product) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ProductMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Product).
func (m *ProductMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.product_id != nil {
		fields = append(fields, product.FieldProductID)
	}
	if m.product_name != nil {
		fields = append(fields, product.FieldProductName)
	}
	if m.product_description != nil {
		fields = append(fields, product.FieldProductDescription)
	}
	if m.product_quantity != nil {
		fields = append(fields, product.FieldProductQuantity)
	}
	if m.unit_price != nil {
		fields = append(fields, product.FieldUnitPrice)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case product.FieldProductID:
		return m.ProductID()
	case product.FieldProductName:
		return m.ProductName()
	case product.FieldProductDescription:
		return m.ProductDescription()
	case product.FieldProductQuantity:
		return m.ProductQuantity()
	case product.FieldUnitPrice:
		return m.UnitPrice()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case product.FieldProductID:
		return m.OldProductID(ctx)
	case product.FieldProductName:
		return m.OldProductName(ctx)
	case product.FieldProductDescription:
		return m.OldProductDescription(ctx)
	case product.FieldProductQuantity:
		return m.OldProductQuantity(ctx)
	case product.FieldUnitPrice:
		return m.OldUnitPrice(ctx)
	}
	return nil, fmt.Errorf("unknown Product field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductMutation) SetField(name string, value ent.Value) error {
	switch name {
	case product.FieldProductID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductID(v)
		return nil
	case product.FieldProductName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductName(v)
		return nil
	case product.FieldProductDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductDescription(v)
		return nil
	case product.FieldProductQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductQuantity(v)
		return nil
	case product.FieldUnitPrice:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnitPrice(v)
		return nil
	}
	return fmt.Errorf("unknown Product field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductMutation) AddedFields() []string {
	var fields []string
	if m.addproduct_id != nil {
		fields = append(fields, product.FieldProductID)
	}
	if m.addproduct_quantity != nil {
		fields = append(fields, product.FieldProductQuantity)
	}
	if m.addunit_price != nil {
		fields = append(fields, product.FieldUnitPrice)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case product.FieldProductID:
		return m.AddedProductID()
	case product.FieldProductQuantity:
		return m.AddedProductQuantity()
	case product.FieldUnitPrice:
		return m.AddedUnitPrice()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductMutation) AddField(name string, value ent.Value) error {
	switch name {
	case product.FieldProductID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProductID(v)
		return nil
	case product.FieldProductQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProductQuantity(v)
		return nil
	case product.FieldUnitPrice:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUnitPrice(v)
		return nil
	}
	return fmt.Errorf("unknown Product numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Product nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductMutation) ResetField(name string) error {
	switch name {
	case product.FieldProductID:
		m.ResetProductID()
		return nil
	case product.FieldProductName:
		m.ResetProductName()
		return nil
	case product.FieldProductDescription:
		m.ResetProductDescription()
		return nil
	case product.FieldProductQuantity:
		m.ResetProductQuantity()
		return nil
	case product.FieldUnitPrice:
		m.ResetUnitPrice()
		return nil
	}
	return fmt.Errorf("unknown Product field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.category_id != nil {
		edges = append(edges, product.EdgeCategoryID)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case product.EdgeCategoryID:
		if id := m.category_id; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcategory_id {
		edges = append(edges, product.EdgeCategoryID)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductMutation) EdgeCleared(name string) bool {
	switch name {
	case product.EdgeCategoryID:
		return m.clearedcategory_id
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductMutation) ClearEdge(name string) error {
	switch name {
	case product.EdgeCategoryID:
		m.ClearCategoryID()
		return nil
	}
	return fmt.Errorf("unknown Product unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductMutation) ResetEdge(name string) error {
	switch name {
	case product.EdgeCategoryID:
		m.ResetCategoryID()
		return nil
	}
	return fmt.Errorf("unknown Product edge %s", name)
}

// StaffMutation represents an operation that mutates the Staff nodes in the graph.
type StaffMutation struct {
	config
	op            Op
	typ           string
	id            *int
	email         *string
	name          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Staff, error)
	predicates    []predicate.Staff
}

var _ ent.Mutation = (*StaffMutation)(nil)

// staffOption allows management of the mutation configuration using functional options.
type staffOption func(*StaffMutation)

// newStaffMutation creates new mutation for the Staff entity.
func newStaffMutation(c config, op Op, opts ...staffOption) *StaffMutation {
	m := &StaffMutation{
		config:        c,
		op:            op,
		typ:           TypeStaff,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStaffID sets the ID field of the mutation.
func withStaffID(id int) staffOption {
	return func(m *StaffMutation) {
		var (
			err   error
			once  sync.Once
			value *Staff
		)
		m.oldValue = func(ctx context.Context) (*Staff, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Staff.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStaff sets the old Staff of the mutation.
func withStaff(node *Staff) staffOption {
	return func(m *StaffMutation) {
		m.oldValue = func(context.Context) (*Staff, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StaffMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StaffMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StaffMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StaffMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Staff.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEmail sets the "email" field.
func (m *StaffMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *StaffMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Staff entity.
// If the Staff object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StaffMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *StaffMutation) ResetEmail() {
	m.email = nil
}

// SetName sets the "name" field.
func (m *StaffMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *StaffMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Staff entity.
// If the Staff object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StaffMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *StaffMutation) ResetName() {
	m.name = nil
}

// Where appends a list predicates to the StaffMutation builder.
func (m *StaffMutation) Where(ps ...predicate.Staff) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *StaffMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Staff).
func (m *StaffMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StaffMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.email != nil {
		fields = append(fields, staff.FieldEmail)
	}
	if m.name != nil {
		fields = append(fields, staff.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StaffMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case staff.FieldEmail:
		return m.Email()
	case staff.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StaffMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case staff.FieldEmail:
		return m.OldEmail(ctx)
	case staff.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Staff field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StaffMutation) SetField(name string, value ent.Value) error {
	switch name {
	case staff.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case staff.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Staff field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StaffMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StaffMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StaffMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Staff numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StaffMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StaffMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StaffMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Staff nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StaffMutation) ResetField(name string) error {
	switch name {
	case staff.FieldEmail:
		m.ResetEmail()
		return nil
	case staff.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Staff field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StaffMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StaffMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StaffMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StaffMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StaffMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StaffMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StaffMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Staff unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StaffMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Staff edge %s", name)
}
